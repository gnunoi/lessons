# 冒泡排序算法C++讲稿

## 一、算法概述

冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换的元素，也就是说该数列已经排序完成。

## 二、算法原理

假设我们有一个数组`arr`，长度为`n`。

1. **外层循环**：控制排序的轮数，总共需要`n-1`轮。因为每一轮都会将最大的元素“冒泡”到数组的最右侧。
2. **内层循环**：在每一轮中，比较相邻的两个元素。如果前一个元素大于后一个元素，则交换它们的位置。内层循环的次数会随着轮数的增加而减少，因为每一轮结束后，末尾的部分已经是有序的。

## 三、示例讲解

假设我们有数组`arr = {64, 34, 25, 12, 22, 11, 90}`，共7个元素。

### 第一轮排序：

- 比较64和34，64>34，交换位置，数组变为{34, 64, 25, 12, 22, 11, 90}。
- 比较64和25，64>25，交换位置，数组变为{34, 25, 64, 12, 22, 11, 90}。
- 比较64和12，64>12，交换位置，数组变为{34, 25, 12, 64, 22, 11, 90}。
- 比较64和22，64>22，交换位置，数组变为{34, 25, 12, 22, 64, 11, 90}。
- 比较64和11，64>11，交换位置，数组变为{34, 25, 12, 22, 11, 64, 90}。
- 比较64和90，64<90，不交换。

第一轮结束后，最大的元素90已经移动到数组的最后一位。

### 第二轮排序：

- 比较34和25，34>25，交换位置，数组变为{25, 34, 12, 22, 11, 64, 90}。
- 比较34和12，34>12，交换位置，数组变为{25, 12, 34, 22, 11, 64, 90}。
- 比较34和22，34>22，交换位置，数组变为{25, 12, 22, 34, 11, 64, 90}。
- 比较34和11，34>11，交换位置，数组变为{25, 12, 22, 11, 34, 64, 90}。
- 比较34和64，34<64，不交换。

第二轮结束后，次大的元素64已经移动到数组的倒数第二位。

### 第三轮排序：

- 比较25和12，25>12，交换位置，数组变为{12, 25, 22, 11, 34, 64, 90}。
- 比较25和22，25>22，交换位置，数组变为{12, 22, 25, 11, 34, 64, 90}。
- 比较25和11，25>11，交换位置，数组变为{12, 22, 11, 25, 34, 64, 90}。
- 比较25和34，25<34，不交换。

第三轮结束后，第三大的元素34已经移动到数组的相应位置。

### 第四轮排序：

- 比较12和22，12<22，不交换。
- 比较22和11，22>11，交换位置，数组变为{12, 11, 22, 25, 34, 64, 90}。
- 比较22和25，22<25，不交换。

第四轮结束后，第四大的元素25已经移动到数组的相应位置。

### 第五轮排序：

- 比较12和11，12>11，交换位置，数组变为{11, 12, 22, 25, 34, 64, 90}。
- 比较12和22，12<22，不交换。

第五轮结束后，第五大的元素22已经移动到数组的相应位置。

### 第六轮排序：

- 比较11和12，11<12，不交换。

第六轮结束后，第六大的元素12已经移动到数组的相应位置。

此时，整个数组已经有序，排序完成。

## 四、数据移动图示

以下是每一轮排序后数组的变化情况：

### 初始数组：
```
64 34 25 12 22 11 90
```

### 第一轮后：
```
34 25 12 22 11 64 90
```

### 第二轮后：
```
25 12 22 11 34 64 90
```

### 第三轮后：
```
12 22 11 25 34 64 90
```

### 第四轮后：
```
12 11 22 25 34 64 90
```

### 第五轮后：
```
11 12 22 25 34 64 90
```

### 第六轮后：
```
11 12 22 25 34 64 90
```

## 五、C++代码实现

```cpp
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) { // 外层循环控制轮数
        for (int j = 0; j < n - i - 1; j++) { // 内层循环控制每一轮的比较
            if (arr[j] > arr[j + 1]) { // 如果前一个元素大于后一个元素
                swap(arr[j], arr[j + 1]); // 交换它们的位置
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);
    cout << "Sorted array: \n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    return 0;
}
```

## 六、算法分析

### 时间复杂度

- **最坏情况**：当数组完全逆序时，需要进行`n-1`轮比较，每轮比较次数为`n-1, n-2, ..., 1`，总次数为`(n-1)*n/2`，时间复杂度为`O(n²)`。
- **最好情况**：当数组已经有序时，只需要进行一轮比较，时间复杂度为`O(n)`。
- **平均情况**：时间复杂度为`O(n²)`。

### 空间复杂度

冒泡排序只需要一个临时变量用于交换元素，因此空间复杂度为`O(1)`。

### 稳定性

冒泡排序是稳定的排序算法。因为在排序过程中，相等的元素的相对位置不会发生改变。

## 七、总结

冒泡排序是一种简单且直观的排序算法，虽然在实际应用中对于大数据量的排序效率不高，但对于小规模数据或者教学演示来说，它是一个很好的选择。通过不断地比较和交换相邻元素，最终将最大的元素逐步“冒泡”到数组的末尾，从而实现整个数组的有序排列。