# 选择排序算法C++讲稿

## 一、算法概述

选择排序（Selection Sort）是一种简单直观的比较排序算法。它的基本思想是：每次从未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，直到全部待排序元素排完。

## 二、算法原理

假设我们要对数组`arr[0], arr[1], ..., arr[n-1]`进行升序排序：

1. 初始时，未排序序列是整个数组。找到未排序序列中的最小值，将其与未排序序列的第一个元素交换位置。
2. 此时，未排序序列少了一个元素（已排序序列多了一个元素）。重复上述过程，直到未排序序列为空。

## 三、具体示例

以数组`[12, 11, 13, 5, 6]`为例，演示选择排序的详细过程：

### 第一轮：

- 未排序序列：`[12, 11, 13, 5, 6]`
- 找到最小值`5`，其索引为3。
- 将索引0和索引3的元素交换，数组变为`[5, 11, 13, 12, 6]`。

### 第二轮：

- 未排序序列：`[11, 13, 12, 6]`（从索引1开始）
- 找到最小值`6`，其索引为4。
- 将索引1和索引4的元素交换，数组变为`[5, 6, 13, 12, 11]`。

### 第三轮：

- 未排序序列：`[13, 12, 11]`（从索引2开始）
- 找到最小值`11`，其索引为4。
- 将索引2和索引4的元素交换，数组变为`[5, 6, 11, 12, 13]`。

### 第四轮：

- 未排序序列：`[12, 13]`（从索引3开始）
- 找到最小值`12`，其索引为3。
- 无需交换，数组仍为`[5, 6, 11, 12, 13]`。

此时，整个数组已排序完成。

## 四、数据移动图示

在每一轮中，我们通过比较找到最小值，并在最后进行一次交换操作。以下是各轮次的数据移动图示：

### 第一轮数据移动：

初始数组：`[12, 11, 13, 5, 6]`

比较过程：
- 比较12和11，较小值为11。
- 比较11和13，较小值仍为11。
- 比较11和5，较小值变为5。
- 比较5和6，较小值仍为5。

找到最小值5后，与第一个元素12交换，得到：`[5, 11, 13, 12, 6]`。

### 第二轮数据移动：

未排序序列：`[11, 13, 12, 6]`

比较过程：
- 比较11和13，较小值为11。
- 比较11和12，较小值仍为11。
- 比较11和6，较小值变为6。

找到最小值6后，与第一个元素11交换，得到：`[5, 6, 13, 12, 11]`。

### 第三轮数据移动：

未排序序列：`[13, 12, 11]`

比较过程：
- 比较13和12，较小值为12。
- 比较12和11，较小值变为11。

找到最小值11后，与第一个元素13交换，得到：`[5, 6, 11, 12, 13]`。

## 五、C++代码实现

```cpp
#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) { // 外层循环控制轮数
        int minIndex = i; // 假设当前i为最小值索引
        for (int j = i + 1; j < n; ++j) { // 内层循环找最小值
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小值索引
            }
        }
        // 交换操作
        if (minIndex != i) { // 如果找到更小的值，才进行交换
            swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    selectionSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    return 0;
}
```

## 六、算法性能分析

- **时间复杂度**：
  - 最好情况：数组已有序，时间复杂度为`O(n²)`（仍需进行所有比较）。
  - 最坏情况：数组逆序，时间复杂度仍为`O(n²)`。
  - 平均时间复杂度：`O(n²)`。
- **空间复杂度**：`O(1)`，仅使用常数级额外空间。
- **稳定性**：不稳定排序。例如，若存在相同元素，在交换过程中可能会改变它们的相对顺序。

## 七、总结

选择排序是一种简单但效率较低的排序算法，适用于数据规模较小的场景。它的实现较为直观，通过不断选择最小值并交换到正确位置完成排序。尽管时间性能不如更高级的排序算法（如快速排序、归并排序），但在某些特定场景下仍有一定的应用价值。