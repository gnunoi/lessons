# 插入排序算法C++讲稿

## 一、算法概述
插入排序是一种简单直观的比较类排序算法。它的工作原理是将一个记录插入到已排序好的有序表中，从而得到一个新的、记录数增加1的有序表。在实现上，我们通常将第一个元素视为已排序序列，然后依次将后面的元素插入到已排序序列中的合适位置。

## 二、算法实现

以下是插入排序算法的C++实现代码，并在注释中详细说明了每一步的操作：
```cpp
#include <iostream>
using namespace std;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) { // 从第二个元素开始，因为第一个元素单独构成有序序列
        int key = arr[i]; // 取出当前待插入的元素
        int j = i - 1;

        // 将比key大的元素依次向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key; // 将key插入到正确的位置
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);

    cout << "排序后的数组: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    return 0;
}
```

## 三、中间过程详细说明
假设我们有一个数组：`{12, 11, 13, 5, 6}`，下面是插入排序的详细过程：

### 初始状态
```
数组：12 11 13 5 6
已排序序列：[12] （视为第一个元素已排序好）
未排序序列：11 13 5 6
```

### 第一次迭代（i=1，key=11）
```
比较11与已排序序列的最后一个元素12，因为11<12，所以将12向后移动一位：
12 12 13 5 6
然后将11插入到12前面的位置：
11 12 13 5 6
此时已排序序列：[11,12]，未排序序列：13 5 6
```

### 第二次迭代（i=2，key=13）
```
比较13与已排序序列的最后一个元素12，因为13>12，所以直接将13插入到已排序序列末尾：
11 12 13 5 6
此时已排序序列：[11,12,13]，未排序序列：5 6
```

### 第三次迭代（i=3，key=5）
```
比较5与已排序序列的最后一个元素13，5<13，将13向后移动：
11 12 13 13 6
继续比较5与12，5<12，将12向后移动：
11 12 12 13 6
继续比较5与11，5<11，将11向后移动：
11 11 12 13 6
将5插入到第一个位置：
5 11 12 13 6
此时已排序序列：[5,11,12,13]，未排序序列：6
```

### 第四次迭代（i=4，key=6）
```
比较6与已排序序列的最后一个元素13，6<13，将13向后移动：
5 11 12 13 13
继续比较6与12，6<12，将12向后移动：
5 11 12 12 13
继续比较6与11，6<11，将11向后移动：
5 11 11 12 13
继续比较6与5，6>5，所以将6插入到5的后面：
5 6 11 12 13
此时已排序序列：[5,6,11,12,13]，未排序序列为空，排序完成。
```

## 四、数据移动的图示
下面是每次迭代中数据移动的图示表示：

### 初始
```
[12] [11] [13] [5] [6]
```

### 第一次迭代后
```
[11] [12] [13] [5] [6]
```

### 第二次迭代后
```
[11] [12] [13] [5] [6]
```

### 第三次迭代后
```
[5] [11] [12] [13] [6]
```

### 第四次迭代后
```
[5] [6] [11] [12] [13]
```

## 五、总结
插入排序算法的时间复杂度为O(n²)，空间复杂度为O(1)，它是一种稳定的排序算法。在实际应用中，当数据规模较小时，插入排序是一种简单有效的排序方法。