\documentclass{article}
\usepackage{amsmath}
\usepackage{ctex}
\usepackage{tikz}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{universe} % 自定义的宏包
\usepackage{titling}
\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}  % 设置页边距为2cm

\usepackage{fancyhdr}
\usepackage{lastpage}  % 引入 lastpage 宏包，获取总页数
% 去掉页眉下的横线
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}  % 清空所有默认设置

% 设置页眉显示页码格式
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}

\title{Python编程入门讲义}
\author{致慧星空工作室}
\date{\today}

\begin{document}
\thispagestyle{empty}  % 首页不显示页码
\vspace*{5cm}  % 设置正文首行距离页面顶部的距离
\centerline{\Huge\textbf{\thetitle}}
\vspace*{10cm}
\centerline{\Large\textbf{\theauthor}}
\vspace*{1cm}
\centerline{\large\thedate}
\newpage

\tableofcontents
\newpage

\section{Python简介}
Python是一种高级编程语言，具有简洁的语法和强大的功能，广泛应用于数据分析、人工智能、自动化等多个领域。它的语法结构清晰，适合初学者入门。本文将从Python的安装到常见的编程技巧进行讲解，并配合具体示例帮助理解。

\section{Python安装与调试工具}
在开始编写Python程序之前，首先需要安装Python解释器和调试工具。

\subsection{安装Python}
1. 访问Python官方网站：\href{https://www.python.org/downloads/}{https://www.python.org/downloads/}，下载适合操作系统的安装包。
2. 安装时，记得勾选\texttt{Add Python to PATH}选项，确保Python能够在命令行中直接调用。

\subsection{调试工具}
常用的Python调试工具包括：
\begin{itemize}
    \item \textbf{IDLE}：Python自带的集成开发环境，简单易用，适合初学者。
    \item \textbf{PyCharm}：功能强大的Python开发工具，适用于较复杂的开发任务。
    \item \textbf{Jupyter Notebook}：适合数据分析和机器学习的环境，可以逐行运行代码并可视化结果。
\end{itemize}

\section{Python基本数据类型}
在Python中，常见的数据类型包括数字、字符串、列表、元组、字典和集合。

\subsection{数字类型}
Python支持整数、浮点数和复数。

\begin{lstlisting}[language=Python,caption=数字类型示例]
# 整数类型
a = 10
print(a)  # 输出: 10

# 浮点数类型
b = 3.14
print(b)  # 输出: 3.14

# 复数类型
c = 1 + 2j
print(c)  # 输出: (1+2j)
\end{lstlisting}

\subsection{字符串类型}
字符串是字符的序列，用单引号或双引号表示。

\begin{lstlisting}[language=Python,caption=字符串类型示例]
# 字符串示例
str1 = "Hello, Python!"
str2 = 'Python 编程'
print(str1)  # 输出: Hello, Python!
print(str2)  # 输出: Python 编程
\end{lstlisting}

\subsection{数据结构}
Python内建了多种数据结构，常见的有列表（list）、元组（tuple）、字典（dict）和集合（set）。

\subsubsection{列表}
列表是一个有序的可变集合，可以存储不同类型的元素。

\begin{lstlisting}[language=Python,caption=列表示例]
# 创建列表
my_list = [1, 2, 3, "Python", 3.14]
print(my_list)  # 输出: [1, 2, 3, 'Python', 3.14]
\end{lstlisting}

\subsubsection{元组}
元组与列表类似，但元组是不可变的。

\begin{lstlisting}[language=Python,caption=元组示例]
# 创建元组
my_tuple = (1, 2, 3, "Python", 3.14)
print(my_tuple)  # 输出: (1, 2, 3, 'Python', 3.14)
\end{lstlisting}

\subsubsection{字典}
字典是键值对的集合，用于存储无序的数据。

\begin{lstlisting}[language=Python,caption=字典示例]
# 创建字典
my_dict = {"name": "Python", "type": "Programming Language", "year": 1991}
print(my_dict)  # 输出: {'name': 'Python', 'type': 'Programming Language', 'year': 1991}
\end{lstlisting}

\subsubsection{集合}
集合是一个无序的、不重复的元素集。

\begin{lstlisting}[language=Python,caption=集合示例]
# 创建集合
my_set = {1, 2, 3, 4, 5}
print(my_set)  # 输出: {1, 2, 3, 4, 5}
\end{lstlisting}

\subsection{数据结构组合}
Python的多种数据结构可以互相嵌套。例如，可以在列表中存储字典、集合等，或者在字典中存储列表。

\begin{lstlisting}[language=Python,caption=数据结构组合示例]
# 列表中存储字典
list_of_dicts = [{"name": "Alice", "age": 25}, {"name": "Bob", "age": 30}]
print(list_of_dicts)  # 输出: [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 30}]

# 字典中存储列表
dict_of_lists = {"names": ["Alice", "Bob"], "ages": [25, 30]}
print(dict_of_lists)  # 输出: {'names': ['Alice', 'Bob'], 'ages': [25, 30]}
\end{lstlisting}

\section{控制结构}
控制结构用于控制程序的执行流程，Python常见的控制结构包括条件语句（if-else）、循环语句（for、while）等。

\subsection{if-else语句}
if-else语句用于根据条件执行不同的代码块。

\begin{lstlisting}[language=Python,caption=if-else语句示例]
# if-else示例
x = 10
if x > 0:
    print("x 是正数")  # 输出: x 是正数
else:
    print("x 不是正数")
\end{lstlisting}

\subsection{for循环}
for循环用于遍历序列（如列表、元组、字典等）。

\begin{lstlisting}[language=Python,caption=for循环示例]
# for循环示例
for i in range(5):
    print(i)  # 输出: 0, 1, 2, 3, 4
\end{lstlisting}

\subsection{while循环}
while循环在满足条件时重复执行。

\begin{lstlisting}[language=Python,caption=while循环示例]
# while循环示例
count = 0
while count < 5:
    print(count)
    count += 1  # 输出: 0, 1, 2, 3, 4
\end{lstlisting}

\section{自定义函数与排序算法}
Python允许用户定义函数，封装重复使用的代码。

\subsection{自定义函数}
函数是可以重复使用的代码块，使用`def`关键字定义。

\begin{lstlisting}[language=Python,caption=自定义函数示例]
# 定义一个简单的加法函数
def add(a, b):
    return a + b

print(add(5, 3))  # 输出: 8
\end{lstlisting}

% 增加冒泡排序的实现与讲解，不节标题不要加编号， 使用自动编号，全部使用latex语法
\subsection{冒泡排序}
在Python中，可以实现多种排序算法。常见的排序算法包括冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序、希尔排序和桶排序。以下是冒泡排序的实现。

冒泡排序是一种简单的排序算法，其基本思想是通过重复遍历待排序的元素，比较相邻元素的大小，并在发现逆序时交换它们的位置。每一轮遍历后，当前未排序部分中的最大（或最小）元素被放到数组的一端，就像水中的气泡一样逐渐浮动到顶端。

冒泡排序的时间复杂度为$O(n^2)$，它的空间复杂度为$O(1)$，由于它是就地排序，因此无需额外的存储空间。

\begin{lstlisting}[language=Python,caption=冒泡排序实现]
# 冒泡排序实现
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False  # 用于优化，如果一轮没有交换，说明已经有序
        for j in range(0, n-i-1):  # 遍历到已排序的部分
            if arr[j] > arr[j+1]:  # 如果前一个元素大于后一个元素，交换
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:  # 如果没有发生交换，提前结束排序
            break
    return arr

arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = bubble_sort(arr)
print("排序后:", sorted_arr)  # 输出: 排序后: [11, 12, 22, 25, 64]
\end{lstlisting}

\subsubsection{冒泡排序的工作原理}
冒泡排序的基本过程是通过相邻元素的比较和交换，把最大（或最小）元素“冒泡”到数组的一端。每进行一次完整的遍历后，数组中最大的元素会被放到正确的位置。

\begin{itemize}
    \item \textbf{外循环：} 控制排序的轮数，每轮确保至少一个元素放到正确的位置。
    \item \textbf{内循环：} 进行相邻元素的比较和交换，确保当前轮中的最大元素被“冒泡”到末端。
\end{itemize}

\noindent
\textbf{冒泡排序的步骤：}
\begin{enumerate}
    \item 初始状态：数组为 \{64, 25, 12, 22, 11\}。
    \item \textbf{第一次外循环}（i=0）：比较相邻元素并交换，结果变为 \{25, 12, 22, 11, 64\}，64冒泡到最后。
    \item \textbf{第二次外循环}（i=1）：再次比较并交换，结果变为 \{12, 22, 11, 25, 64\}，25冒泡到倒数第二位。
    \item \textbf{第三次外循环}（i=2）：继续交换，结果变为 \{12, 11, 22, 25, 64\}，22冒泡到倒数第三位。
    \item \textbf{第四次外循环}（i=3）：继续交换，最终数组变为 \{11, 12, 22, 25, 64\}。
\end{enumerate}

\noindent
\textbf{冒泡排序的结果：}
最终的排序结果为 \{11, 12, 22, 25, 64\}。

\subsubsection{冒泡排序的优缺点}
冒泡排序的优缺点如下：

\begin{itemize}
    \item \textbf{优点：}
    \begin{itemize}
        \item 实现简单。
        \item 空间复杂度为$O(1)$，是就地排序。
        \item 在某些情况下（如数据已经部分有序），可以提前结束排序，减少不必要的操作。
    \end{itemize}
    \item \textbf{缺点：}
    \begin{itemize}
        \item 时间复杂度为$O(n^2)$，效率较低。
        \item 即使在数据已部分有序时，算法仍然会进行多次不必要的遍历。
    \end{itemize}
\end{itemize}

\subsubsection{时间复杂度分析}
冒泡排序的时间复杂度是$O(n^2)$，原因在于每一轮外循环都需要进行一次内循环，内循环的比较次数随着外循环的增加逐渐减少。虽然冒泡排序在数据几乎有序时可以提前结束，但最坏情况下，算法仍然需要进行$\frac{n(n-1)}{2}$次比较和交换。

\noindent
\textbf{冒泡排序的空间复杂度：}
冒泡排序是就地排序，不需要额外的空间来存储临时数据，因此其空间复杂度为$O(1)$。

\subsubsection{冒泡排序的可视化}
以下是冒泡排序的可视化图示（请使用TikZ绘制图形）：

\begin{tikzpicture}
    % 图示描述冒泡排序的每次交换
    \node at (0, 0) {初始数组: \{64, 25, 12, 22, 11\}};
    \node at (0, -1) {第一次交换: \{25, 12, 22, 11, 64\}};
    \node at (0, -2) {第二次交换: \{12, 22, 11, 25, 64\}};
    \node at (0, -3) {第三次交换: \{12, 11, 22, 25, 64\}};
    \node at (0, -4) {排序完成: \{11, 12, 22, 25, 64\}};
\end{tikzpicture}

% 增加选择排序的实现与讲解，不节标题不要加编号， 使用自动编号，全部使用latex语法
\subsection{选择排序}
选择排序是一种简单的排序算法，它的基本思想是通过遍历待排序的数组，找到最小（或最大）元素并将其交换到已排序部分的末尾。选择排序的工作原理是每一轮遍历都从未排序部分中选择出最小（或最大）元素，将其与当前遍历的第一个元素交换位置。

选择排序的时间复杂度为$O(n^2)$，它的空间复杂度为$O(1)$，因为选择排序是原地排序。

\begin{lstlisting}[language=Python,caption=选择排序实现]
# 选择排序实现
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i  # 假设当前元素是最小值
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j  # 更新最小值的索引
        arr[i], arr[min_idx] = arr[min_idx], arr[i]  # 交换位置
    return arr

arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = selection_sort(arr)
print("排序后:", sorted_arr)  # 输出: 排序后: [11, 12, 22, 25, 64]
\end{lstlisting}

\subsubsection{选择排序的工作原理}
选择排序的基本过程如下：
\begin{enumerate}
    \item 从未排序部分中选择最小（或最大）元素。
    \item 将选中的最小（或最大）元素与当前元素交换。
    \item 重复上述过程，直到所有元素都被排序。
\end{enumerate}

\noindent
\textbf{选择排序的步骤：}
\begin{itemize}
    \item 初始状态：数组为 \{64, 25, 12, 22, 11\}。
    \item \textbf{第一次外循环}（i=0）：找到最小元素11，交换位置，数组变为 \{11, 25, 12, 22, 64\}。
    \item \textbf{第二次外循环}（i=1）：找到最小元素12，交换位置，数组变为 \{11, 12, 25, 22, 64\}。
    \item \textbf{第三次外循环}（i=2）：找到最小元素22，交换位置，数组变为 \{11, 12, 22, 25, 64\}。
    \item \textbf{第四次外循环}（i=3）：找到最小元素25，交换位置，数组变为 \{11, 12, 22, 25, 64\}。
    \item \textbf{第五次外循环}（i=4）：不需要交换，数组已经排序完毕。
\end{itemize}

\noindent
\textbf{选择排序的结果：}
最终的排序结果为 \{11, 12, 22, 25, 64\}。

\subsubsection{选择排序的优缺点}
选择排序的优缺点如下：

\begin{itemize}
    \item \textbf{优点：}
    \begin{itemize}
        \item 实现简单。
        \item 空间复杂度为$O(1)$，是就地排序。
    \end{itemize}
    \item \textbf{缺点：}
    \begin{itemize}
        \item 时间复杂度为$O(n^2)$，效率较低。
        \item 不管数据是否有序，选择排序的每一轮都会进行遍历，导致无效的比较和交换。
    \end{itemize}
\end{itemize}

\subsubsection{时间复杂度分析}
选择排序的时间复杂度是$O(n^2)$，这是因为它需要两层循环来遍历元素，外层循环遍历所有元素，内层循环查找未排序部分中的最小元素。无论数据是否有序，选择排序的每一轮都必须执行$n-i-1$次比较（其中$i$是当前外循环的索引）。

\noindent
\textbf{选择排序的空间复杂度：}
选择排序是就地排序，它只需要常量空间来存储最小值的索引，因此其空间复杂度为$O(1)$。

\subsubsection{选择排序的可视化}
以下是选择排序的可视化图示（请使用TikZ绘制图形）：

\begin{tikzpicture}
    % 图示描述选择排序的每次交换
    \node at (0, 0) {初始数组: \{64, 25, 12, 22, 11\}};
    \node at (0, -1) {第一次交换: \{11, 25, 12, 22, 64\}};
    \node at (0, -2) {第二次交换: \{11, 12, 25, 22, 64\}};
    \node at (0, -3) {第三次交换: \{11, 12, 22, 25, 64\}};
    \node at (0, -4) {排序完成: \{11, 12, 22, 25, 64\}};
\end{tikzpicture}

\subsection{插入排序}
插入排序是一种简单的排序算法，它的基本思想是通过将每个待排序元素插入到已排序部分的合适位置来实现排序。插入排序适用于小规模数据的排序，且在数据接近有序时非常高效。

插入排序的时间复杂度为$O(n^2)$，但在最优情况下（即数据已经部分有序时），时间复杂度可以降到$O(n)$。空间复杂度为$O(1)$，因为插入排序是原地排序。

\begin{lstlisting}[language=Python,caption=插入排序实现]
# 插入排序实现
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]  # 当前元素
        j = i - 1
        # 向左移位，找到合适的位置
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key  # 插入元素
    return arr

arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = insertion_sort(arr)
print("排序后:", sorted_arr)  # 输出: 排序后: [11, 12, 22, 25, 64]
\end{lstlisting}

\subsubsection{插入排序的工作原理}
插入排序通过将当前元素与前面的元素进行比较，并把当前元素插入到合适的位置来实现排序。具体步骤如下：
1. 从第二个元素开始，假设第一个元素已经是排序好的。
2. 将当前元素与已排序部分的元素从右到左进行比较，直到找到合适的位置。
3. 将当前元素插入到已排序部分的合适位置。

\noindent
\textbf{插入排序的步骤：}
\begin{itemize}
    \item 初始状态：数组为 \{64, 25, 12, 22, 11\}。
    \item \textbf{第一次外循环}（i=1）：当前元素25，比较并插入到第一个位置，数组变为 \{25, 64, 12, 22, 11\}。
    \item \textbf{第二次外循环}（i=2）：当前元素12，比较并插入到第二个位置，数组变为 \{12, 25, 64, 22, 11\}。
    \item \textbf{第三次外循环}（i=3）：当前元素22，比较并插入到第三个位置，数组变为 \{12, 22, 25, 64, 11\}。
    \item \textbf{第四次外循环}（i=4）：当前元素11，比较并插入到最前面，数组变为 \{11, 12, 22, 25, 64\}。
\end{itemize}

\noindent
\textbf{插入排序的结果：}
最终的排序结果为 \{11, 12, 22, 25, 64\}。

\subsubsection{插入排序的优缺点}
插入排序的优缺点如下：

\begin{itemize}
    \item \textbf{优点：}
    \begin{itemize}
        \item 对于少量数据或者接近有序的数组，插入排序非常高效。
        \item 插入排序是稳定的排序算法，即相同元素的相对顺序不会改变。
        \item 空间复杂度为$O(1)$，是原地排序。
    \end{itemize}
    \item \textbf{缺点：}
    \begin{itemize}
        \item 时间复杂度为$O(n^2)$，对于大规模数据，效率较低。
    \end{itemize}
\end{itemize}

\subsubsection{时间复杂度分析}
插入排序的时间复杂度为$O(n^2)$，在最坏的情况下，每个元素都需要与前面所有的元素进行比较。若数据已经部分有序，则插入排序的时间复杂度可以降到$O(n)$。

\noindent
\textbf{插入排序的空间复杂度：}
由于插入排序是在原数组上进行排序，不需要额外的存储空间，因此空间复杂度为$O(1)$。

\subsection{插入排序的可视化}
以下是插入排序的可视化图示（请使用TikZ绘制图形）：

\begin{tikzpicture}
    % 图示描述插入排序的每次插入
    \node at (0, 0) {初始数组: \{64, 25, 12, 22, 11\}};
    \node at (0, -1) {第一次插入: \{25, 64, 12, 22, 11\}};
    \node at (0, -2) {第二次插入: \{12, 25, 64, 22, 11\}};
    \node at (0, -3) {第三次插入: \{12, 22, 25, 64, 11\}};
    \node at (0, -4) {第四次插入: \{11, 12, 22, 25, 64\}};
    \node at (0, -5) {排序完成: \{11, 12, 22, 25, 64\}};
\end{tikzpicture}

% 增加希尔排序的实现与讲解，节标题不要加上需要， 使用自动编号，完全不适用Markdown语法，如有全部转换成latex语法
\subsection{希尔排序}
希尔排序（Shell Sort）是插入排序的一种改进算法，它通过定义一个增量序列，将待排序数组分成多个子序列，对这些子序列分别进行插入排序，逐步减少增量，直到增量为1时完成排序。

希尔排序的关键在于选择增量序列。一个好的增量序列可以显著提高排序的效率。最初，增量通常是数组长度的一半，然后逐步减小，直到增量为1为止。

希尔排序的时间复杂度取决于增量序列的选择。在最坏的情况下，时间复杂度为$O(n^2)$，但在理想情况下，希尔排序的时间复杂度可以降到$O(n^{3/2})$或更好。空间复杂度为$O(1)$。

\begin{lstlisting}[language=Python,caption=希尔排序实现]
# 希尔排序实现
def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # 初始增量
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # 缩小增量
    return arr

arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = shell_sort(arr)
print("排序后:", sorted_arr)  # 输出: 排序后: [11, 12, 22, 25, 64]
\end{lstlisting}

\subsubsection{希尔排序的工作原理}
希尔排序的基本思想是先将整个待排序的数组按某个增量（gap）分组，然后对每组使用插入排序进行排序。随着增量逐渐减小，最终当增量为1时，整个数组会变得接近有序，最后一次插入排序完成排序。

\noindent
\textbf{希尔排序的步骤：}
\begin{itemize}
    \item 初始状态：数组为 \{64, 25, 12, 22, 11\}。
    \item \textbf{第一次外循环}（gap = 2）：将数组分为3组，分别为 \{64, 12\}, \{25, 22\}, \{11\}，进行插入排序。
    \item \textbf{第二次外循环}（gap = 1）：将增量减小为1，再次进行插入排序。
    \item 排序完成：最终数组变为 \{11, 12, 22, 25, 64\}。
\end{itemize}

\noindent
\textbf{希尔排序的结果：}
最终的排序结果为 \{11, 12, 22, 25, 64\}。

\subsubsection{希尔排序的优缺点}
希尔排序的优缺点如下：

\begin{itemize}
    \item \textbf{优点：}
    \begin{itemize}
        \item 比插入排序效率更高，特别是在数据规模较大的情况下。
        \item 在数据部分有序时表现尤为出色。
        \item 时间复杂度和空间复杂度相对较优，空间复杂度为$O(1)$。
    \end{itemize}
    \item \textbf{缺点：}
    \begin{itemize}
        \item 希尔排序依赖于增量序列的选择，选择不当可能导致效率低下。
        \item 相对于快速排序等高效排序算法，最坏情况下的时间复杂度仍较高。
    \end{itemize}
\end{itemize}

\subsubsection{时间复杂度分析}
希尔排序的时间复杂度与所选的增量序列密切相关。对于最常见的增量序列（如将gap从数组长度一半开始逐渐减小），最坏情况下的时间复杂度为$O(n^2)$。然而，通过合适的增量序列，时间复杂度可以降到$O(n^{3/2})$，或者更好的$O(n \log n)$。

\noindent
\textbf{希尔排序的空间复杂度：}
由于希尔排序是原地排序，只需要常数级别的额外空间，因此其空间复杂度为$O(1)$。

\subsubsection{希尔排序的可视化}
以下是希尔排序的可视化图示（请使用TikZ绘制图形）：

\begin{tikzpicture}
    % 图示描述希尔排序的每次分组和排序
    \node at (0, 0) {初始数组: \{64, 25, 12, 22, 11\}};
    \node at (0, -1) {第一次外循环 (gap=2): \{64, 12\}, \{25, 22\}, \{11\}};
    \node at (0, -2) {第二次外循环 (gap=1): \{11, 12, 22, 25, 64\}};
    \node at (0, -3) {排序完成: \{11, 12, 22, 25, 64\}};
\end{tikzpicture}

\subsection{堆排序}
堆排序是一种基于堆这种数据结构的排序算法。堆是一种完全二叉树，可以分为最大堆和最小堆。最大堆是指父节点的值大于或等于其子节点的值，而最小堆则相反。堆排序的基本思想是利用堆的特性来逐步将最大（或最小）元素放到数组的末尾，从而实现排序。

堆排序分为两步：
1. 构建一个最大堆。
2. 交换堆顶元素和末尾元素，并重新调整堆，直到排序完成。

堆排序的时间复杂度为$O(n \log n)$，空间复杂度为$O(1)$。

\begin{lstlisting}[language=Python,caption=堆排序实现]
# 堆排序实现
def heapify(arr, n, i):
    largest = i  # 初始化最大元素为当前根节点
    left = 2 * i + 1  # 左子节点的索引
    right = 2 * i + 2  # 右子节点的索引

    # 如果左子节点比根节点大
    if left < n and arr[left] > arr[largest]:
        largest = left

    # 如果右子节点比根节点大
    if right < n and arr[right] > arr[largest]:
        largest = right

    # 如果最大值不是根节点
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # 交换
        heapify(arr, n, largest)  # 递归调整堆

def heap_sort(arr):
    n = len(arr)

    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 一个一个地取出元素
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 交换根节点和末尾元素
        heapify(arr, i, 0)  # 调整堆
    return arr

arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = heap_sort(arr)
print("排序后:", sorted_arr)  # 输出: 排序后: [11, 12, 22, 25, 64]
\end{lstlisting}

\subsubsection{堆排序的工作原理}
堆排序的基本过程可以分为两个阶段：\\
1. **构建最大堆：** 从最后一个非叶子节点开始，从下至上进行调整，使得每个父节点都大于或等于其子节点。\\
2. **排序阶段：** 将堆顶元素与堆的最后一个元素交换，然后将堆的大小减少1，重新调整堆。重复这一过程，直到堆的大小为1。

\noindent
\textbf{堆排序的步骤：}
\begin{itemize}
    \item 初始状态：数组为 \{64, 25, 12, 22, 11\}。
    \item \textbf{构建最大堆}：调整数组，使得每个节点满足最大堆的性质。
    \item \textbf{交换堆顶元素和最后一个元素}：将堆顶元素64与数组最后的元素11交换，数组变为 \{11, 25, 12, 22, 64\}，然后调整堆。
    \item \textbf{继续交换和调整堆}：重复交换和堆调整过程，直到堆完全有序。
\end{itemize}

\noindent
\textbf{堆排序的结果：}
最终的排序结果为 \{11, 12, 22, 25, 64\}。

\subsubsection{堆排序的优缺点}
堆排序的优缺点如下：

\begin{itemize}
    \item \textbf{优点：}
    \begin{itemize}
        \item 时间复杂度为$O(n \log n)$，较适合大规模数据排序。
        \item 空间复杂度为$O(1)$，是原地排序。
    \end{itemize}
    \item \textbf{缺点：}
    \begin{itemize}
        \item 相比快速排序，堆排序的常数因子较大，实际效率略低。
        \item 不稳定排序，不能保持相同元素的相对顺序。
    \end{itemize}
\end{itemize}

\subsubsection{时间复杂度分析}
堆排序的时间复杂度为$O(n \log n)$，这是因为：\\
1. 构建最大堆的时间复杂度是$O(n)$。\\
2. 在排序过程中，每次需要对堆进行调整，调整的时间复杂度是$O(\log n)$，每次调整操作需要进行$n-1$次。

\noindent
\textbf{堆排序的空间复杂度：}
堆排序是就地排序，除了输入数组外，不需要额外的空间，因此其空间复杂度为$O(1)$。

\subsubsection{堆排序的可视化}
以下是堆排序的可视化图示（请使用TikZ绘制图形）：

\begin{tikzpicture}
    % 图示描述堆排序的每次交换和调整堆
    \node at (0, 0) {初始数组: \{64, 25, 12, 22, 11\}};
    \node at (0, -1) {构建最大堆: \{64, 25, 12, 22, 11\}};
    \node at (0, -2) {交换堆顶元素与末尾: \{11, 25, 12, 22, 64\}};
    \node at (0, -3) {调整堆: \{25, 22, 12, 11, 64\}};
    \node at (0, -4) {继续交换和调整堆: \{11, 12, 22, 25, 64\}};
    \node at (0, -5) {排序完成: \{11, 12, 22, 25, 64\}};
\end{tikzpicture}



\subsection{八皇后问题}
八皇后问题是经典的回溯算法问题。我们定义一个类来解决此问题。

\begin{lstlisting}[language=Python,caption=八皇后问题示例]
# 八皇后问题实现
class NQueens:
    def __init__(self, n):
        self.n = n
        self.board = [[0] * n for _ in range(n)]

    def solve(self):
        if self.solve_util(0):
            self.print_board()
        else:
            print("没有解")

    def solve_util(self, row):
        if row == self.n:
            return True
        for col in range(self.n):
            if self.is_safe(row, col):
                self.board[row][col] = 1
                if self.solve_util(row + 1):
                    return True
                self.board[row][col] = 0
        return False

    def is_safe(self, row, col):
        for i in range(row):
            if self.board[i][col] == 1:
                return False
            if col - (row - i) >= 0 and self.board[i][col - (row - i)] == 1:
                return False
            if col + (row - i) < self.n and self.board[i][col + (row - i)] == 1:
                return False
        return True

    def print_board(self):
        for row in self.board:
            print(" ".join(["Q" if x == 1 else "." for x in row]))
\end{lstlisting}

\section{错误分析与调试技巧}
在编程过程中，常见的错误包括语法错误、逻辑错误等。以下是一些常见错误示例及其分析：

\subsection{语法错误示例}
\begin{lstlisting}[language=Python,caption=语法错误示例]
# 缺少括号导致的语法错误
print "Hello, World!"
\end{lstlisting}
错误信息：\texttt{SyntaxError: missing parentheses in call to 'print'}

\subsection{逻辑错误示例}
\begin{lstlisting}[language=Python,caption=逻辑错误示例]
# 计算1到n的和，但未正确初始化sum
def sum_numbers(n):
    for i in range(1, n+1):
        sum += i  # 错误：sum未定义
    return sum
\end{lstlisting}

\subsection{调试技巧}
在调试Python程序时，常用技巧包括：
\begin{itemize}
    \item 使用\texttt{print()}函数输出变量值，帮助追踪代码执行过程。
    \item 使用\texttt{pdb}模块进行单步调试。
\end{itemize}

\section{练习题}
\subsection{基础练习}
\begin{itemize}
    \item 编写一个函数，接受一个数字列表，返回其中的最大值和最小值。
    \item 编写一个函数，接受两个字符串，检查它们是否是回文。
\end{itemize}

\subsection{高级练习}
\begin{itemize}
    \item 实现归并排序。
    \item 实现一个栈类，支持push、pop、peek操作。
\end{itemize}

\section{参考文献}
\begin{itemize}
    \item Python官方文档：\href{https://docs.python.org}{https://docs.python.org}
    \item 《Python编程快速上手》 — Eric Matthes
\end{itemize}

\end{document}
